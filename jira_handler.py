import os

from datetime import datetime
from jira import JIRA

#[('71', 'No longer a vulnerability'), ('81', 'False positive'), ('221', 'Triage Vulnerability'), ('231', 'Out of scope'), ('241', 'Duplicated vulnerability'), ('101', 'Report Vulnerability'), ('201', 'Require further details'), ('161', 'Accept Vulnerability'), ('121', 'Vulnerability fixed')]

class JiraHandler:

    TIMESTAMP = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")

    PARENT_ISSUETYPE = "Repository"
    CHILD_ISSUETYPE = "Repository Vulnerability"

    LOCATION_FIELD = "customfield_17625"
    HASH_FIELD = "customfield_17626"
    SEVERITY_FIELD = "customfield_17567"

    LABEL_MATCH = "appsec-pipeline-sast"

    FIXED_STATUS = "Vulnerability fixed"
    FIXED_TRANSITION = "121" # Vulnerability fixed transition
    FIXED_COMMENT = f"This ticket has been marked as fixed due to it no longer being present in the most recent scan.\n(comment generated by lambda at {TIMESTAMP})"

    REPORTED_TRANSITION = "101"

    open_statuses = [
        "awaiting triage",
        "awaiting further details",
        "reported",
        "false positive",
        "vulnerability accepted"
    ] 

    def __init__(self, metadata):
        print("\n[jira][__init__] instantiated")

        self.m = metadata

        self.j = JIRA(
                    os.getenv("JIRA_SERVER"),
                    basic_auth = (
                        os.getenv("JIRA_USERNAME"),
                        os.getenv("JIRA_API_TOKEN")
                    )
                )
        self.project = metadata["jira_project"]

    def generate_labels(self, issue):
        return [
            f'appsec-pipeline-sast-{issue["tool_name"]}'
        ]

    def generate_severity(self, issue):
        if issue["severity"] == "info":
            return "Informational Only"
        else:
            return issue["severity"].capitalize()

    def check_repository(self, repository):
        print(f"[jira][check_repository] looking for the ticket for the {repository} repository")

        search_string = f'Summary ~ "{repository}" '
        search_string += f' AND project = "{self.project}"'
        search_string += f' AND issuetype = "{self.PARENT_ISSUETYPE}"'

        repository_ticketss = self.j.search_issues(search_string, validate_query=True)
        if len(repository_ticketss) >= 1:
            ticket = repository_ticketss[0]
            print(f"[jira][check_repository] > found \"{ticket.key}: {ticket.fields.summary}\"")
            return ticket

        # No ticket for this repository exists, so lets make it
        else:
            print(f"[jira][check_repository] > no issue found, creating one")
            repository_url = f'https://github.com/{self.m["project_username"]}/{self.m["repository"]}'
            repository_fields = {
                "project": self.project,
                "summary": repository,
                "issuetype": self.PARENT_ISSUETYPE,
                "customfield_17624": repository_url
            }

            # Make the issue then recursively run again to get the correct ticket
            self.j.create_issue(fields = repository_fields)
            print(f"[jira][check_repository] > ticket created, trying again...")
            return self.check_repository(repository)

    def create_jira_tickets(self, issues):
        print(f"[jira][create_jira_tickets] attempting to create JIRA tickets for the issues found")

        # Get (or create) the ticket for the repository we're dealing with
        repository = self.check_repository(self.m["repository"])

        assignee = None

        # Find out who the assignee is
        if repository.fields.assignee is not None:
            assignee = repository.fields.assignee.accountId

        print(f"[jira][create_jira_tickets] checking if this repository's subtasks match the issues we have")
        for issue in issues:

            # Create some new keys to stop KeyError from happening
            issue["status"] = ""
            issue["jira"] = ""

            issue_hash = issue["uid"]
            print(f"[jira][create_jira_tickets] ---")
            print(f"[jira][create_jira_tickets] searching subtasks for id ending in {issue_hash[-5:]}")
            create_issue = True
            if len(repository.fields.subtasks) > 0:
                for subtask in repository.fields.subtasks:

                    # This may have to change if you use a different custom field value for issue hashes
                    subtask_hash = self.j.issue(subtask.key).fields.customfield_17626

                    if subtask_hash is not None:
                        if subtask_hash == issue_hash:
                            print(f"[jira][create_jira_tickets] > found ticket with matching hash: {subtask.key} - {subtask.fields.summary}")
                            status = str(subtask.fields.status)
                            if status.lower() in self.open_statuses:
                                print(f'[jira][create_jira_tickets] >>> this ticket has a status of "{status.lower()}", we won\'t raise a new one')
                                issue["jira"] = subtask.key
                                issue["status"] = status.lower()
                                if status.lower() == "vulnerability accepted":
                                    print("[jira][create_jira_tickets] >>> we will not comment on this issue either as it is accepted")
                                # issue_tickets.append(subtask.key)
                                create_issue = False
                                break
                            # We reach this stage if the ticket is not open BUT we're not going to make a new ticket
                            # (perhaps because we've found another ticket with the hash that IS open)
                            else:
                                print(f"[jira][create_jira_tickets] >>> {subtask.key} is closed")
            if create_issue:
                print("[jira][create_jira_tickets] > no existing open issue found; creating a new one")

                # set the title to the issue title + some branching information
                summary = ""
                if self.m["is_pr"]:
                    summary += f'[PR#{self.m["pr_info"]["pr_number"]}]'
                summary += f'[{self.m["branch"]}] '
                summary += issue["title"]

                description = f'{issue["description"]}'
                description += f'\n\nh4. Recommendation\n{issue["recommendation"]}'
                issue_fields = {
                    "project": self.project,
                    "issuetype": self.CHILD_ISSUETYPE,
                    "parent": {"key": repository.key},
                    "summary": summary,
                    "description": description,
                    self.LOCATION_FIELD: issue["location"],
                    self.HASH_FIELD: issue_hash,
                    "labels": self.generate_labels(issue)
                }
                if issue["severity"] is not None:
                    issue_fields[self.SEVERITY_FIELD] = {
                        "value": self.generate_severity(issue)
                    }
                issue_ticket = self.j.create_issue(fields = issue_fields)
                print(f"[jira][create_jira_tickets] >>> created {issue_ticket.key}")
                issue["jira"] = issue_ticket.key

                # If we have a parent assignee, assign them to the sub-task ticket and transition it to reported
                if assignee is not None:
                    print(f"[jira][create_jira_tickets] >>> the repository ticket has an assignee, assigning them to this also")
                    issue_ticket.update(
                        assignee = {
                            "id": assignee
                        }
                    )
                    self.j.transition_issue(issue_ticket, self.REPORTED_TRANSITION)

                # issue_tickets.append(issue_ticket.key)
        print(f"[jira][create_jira_tickets] ---")


    def prune(self, issues):
        """
        Transition issues that aren't from this report, but were before.
        """

        print()
        print(f"[jira][check_validity] looking for isolated tickets and marking them as fixed")

        repository = self.check_repository(self.m["repository"])

        # Only proceed if we have subtasks
        if len(repository.fields.subtasks) > 0:
            zombie_tickets = []

            for subtask in repository.fields.subtasks:
                subtask = self.j.issue(subtask.key)
                subtask_hash = subtask.raw["fields"][self.HASH_FIELD]

                # Only proceed if there are labels
                if len(subtask.fields.labels) > 0:

                    # If we have a pipeline label then it's a ticket we care about
                    if any(self.LABEL_MATCH in label for label in subtask.fields.labels):
                        # However, if it doesn't have a hash in this report, we need to track it
                        if not any(subtask_hash == issue["uid"] for issue in issues):
                            zombie_tickets.append(subtask.key)

            print(f"[jira][check_validity] we have {len(zombie_tickets)} zombie ticket(s) not in this report")
            print(f"[jira][check_validity] > checking if we can change states")

            for zombie in zombie_tickets:
                
                zombie = self.j.issue(zombie)
                if str(zombie.fields.status).lower() != self.FIXED_STATUS.lower():
                    print(f"[jira][check_validity] >>> changing {zombie}")
                    self.j.transition_issue(zombie, self.FIXED_TRANSITION)
                    self.j.add_comment(zombie, self.FIXED_COMMENT)
                    print(f"[jira][check_validity] >>>>>> changed and commented on!")
                else:
                    print(f"[jira][check_validity] >>>>>> {zombie} is already marked as fixed, skipping")
        