import json
import os
import threading

from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from jira import JIRA

#[('71', 'No longer a vulnerability'), ('81', 'False positive'), ('221', 'Triage Vulnerability'), ('231', 'Out of scope'), ('241', 'Duplicated vulnerability'), ('101', 'Report Vulnerability'), ('201', 'Require further details'), ('161', 'Accept Vulnerability'), ('121', 'Vulnerability fixed')]

class JiraHandler:

    TIMESTAMP = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")

    MAX_WORKERS = 10

    PARENT_ISSUETYPE = "Repository"
    CHILD_ISSUETYPE = "Repository Vulnerability"

    REPOSITORY_FIELD = "customfield_17624"
    LOCATION_FIELD = "customfield_17625"
    HASH_FIELD = "customfield_17626"
    SEVERITY_FIELD = "customfield_17567"

    LABEL_MATCH = "appsec-pipeline-sast"

    FIXED_STATUS = "Vulnerability fixed"
    FIXED_TRANSITION = "121" # Vulnerability fixed transition
    FIXED_COMMENT = f"This ticket has been marked as fixed due to it no longer being present in the most recent scan.\n(comment generated by lambda at {TIMESTAMP})"

    REPORTED_TRANSITION = "101"

    open_statuses = [
        "awaiting triage",
        "awaiting further details",
        "reported",
        "false positive",
        "vulnerability accepted"
    ] 

    def __init__(self, slack, metadata, issues):
        print("\n[jira][__init__] instantiated")

        self.s = slack
        self.m = metadata
        self.i = issues

        self.j = JIRA(
                    os.getenv("JIRA_SERVER"),
                    basic_auth = (
                        os.getenv("JIRA_USERNAME"),
                        os.getenv("JIRA_API_TOKEN")
                    )
                )
        self.project = metadata["jira_project"]

        # Get (or create) the ticket for the repository we're dealing with
        self.repository = self.__check_repository(self.m["repository"])

        self.subtask_information = []
        self.zombie_count = 0
        self.subtasks_exist = self.__generate_subtask_information(self.repository)


    def __generate_labels(self, issue):
        return [
            f'appsec-pipeline-sast-{issue["tool_name"]}'
        ]


    def __generate_severity(self, issue):
        if issue["severity"] == "info":
            return "Informational Only"
        else:
            return issue["severity"].capitalize()


    def __check_repository(self, repository):
        print(f"[jira][__check_repository] looking for the ticket for the {repository} repository")

        search_string = f'Summary ~ "{repository}" '
        search_string += f' AND project = "{self.project}"'
        search_string += f' AND issuetype = "{self.PARENT_ISSUETYPE}"'

        repository_tickets = self.j.search_issues(search_string, validate_query=True)
        if len(repository_tickets) >= 1:
            ticket = repository_tickets[0]
            print(f"[jira][__check_repository] > found \"{ticket.key}: {ticket.fields.summary}\"")
            return ticket

        # No ticket for this repository exists, so lets make it
        else:
            print(f"[jira][__check_repository] > no issue found, creating one")
            repository_url = f'https://github.com/{self.m["project_username"]}/{self.m["repository"]}'
            repository_fields = {
                "project": self.project,
                "summary": repository,
                "issuetype": self.PARENT_ISSUETYPE,
                self.REPOSITORY_FIELD: repository_url
            }

            # Make the issue then recursively run again to get the correct ticket
            self.j.create_issue(fields = repository_fields)
            print(f"[jira][__check_repository] > ticket created, trying again...")
            return self.__check_repository(repository)


    def __get_subtask(self, subtask):
        fields = self.j.issue(subtask.key).raw["fields"]
        subtask_entry = {
            "key": subtask.key,
            "summary": fields["summary"],
            "hash": fields[self.HASH_FIELD],
            "status": fields["status"]["name"].lower(),
            "zombie": False
        }

        # Check if the ticket is a zombie, i.e. it is a issue not in the current report
        # First check if there are labels, and if so, if any of the subtask's labels indicate it was generated
        #   by this tool previously
        if len(fields["labels"]) > 0 and any(self.LABEL_MATCH in label for label in fields["labels"]):
            # At this point we know the subtask was generated by this tool.
            # Now, if the following are all true:
            # - the subtask's hash does not exist in this scan's list of issues
            # - the subtask is open
            # then it's a zombie.
            if not any(subtask_entry["hash"] == issue["uid"] for issue in self.i) and subtask_entry["status"] != FIXED_STATUS.lower():
                subtask_entry["zombie"] = True
                self.zombie_count += 1

        self.subtask_information.append(subtask_entry)
        return


    def __generate_subtask_information(self, repository):
        subtasks = repository.fields.subtasks

        if len(subtasks) > 0:
            print(f"[jira][__generate_subtask_information] collecting information on {len(subtasks)} subtasks")
            with ThreadPoolExecutor(max_workers = self.MAX_WORKERS) as executor:
                executor.map(self.__get_subtask, subtasks)
            return True
        else:
            print(f"[jira][__generate_subtask_information] there are no subtasks to look through")
            return False


    def __prepare_description(self, issue):
        description = f'{issue["description"]}'
        description += f'\n\nh4. Recommendation\n{issue["recommendation"]}'

        return description


    def __create_jira_ticket(self, issue):
        issue_hash = issue["uid"]

        # print(f"[jira][create_jira_tickets] > no existing open issue found for id ending in {issue_hash[-5:]}; creating a new one")

        # Find out who the assignee is
        if self.repository.fields.assignee is not None:
            assignee = self.repository.fields.assignee.accountId
        else:
            assignee = None
        
        if self.m["is_pr"]:
            summary = f'[PR#{self.m["pr_info"]["pr_number"]}] {issue["title"]}'
        else:
        # summary += f'[{self.m["branch"]}] '
            summary = issue["title"]

        # Prepare the description and add the recommendation (with heading) after it
        description = self.__prepare_description(issue)

        # Populate the payload to send to JIRA
        issue_fields = {
            "project": self.project,
            "issuetype": self.CHILD_ISSUETYPE,
            "parent": {"key": self.repository.key},
            "summary": summary,
            "description": description,
            self.LOCATION_FIELD: issue["location"],
            self.HASH_FIELD: issue_hash,
            self.SEVERITY_FIELD: {
                "value": self.__generate_severity(issue)
            },
            "labels": self.__generate_labels(issue)
        }

        issue_ticket = self.j.create_issue(fields = issue_fields)
        issue["jira"] = issue_ticket.key

        output = f"[jira][__create_jira_tickets] issue hash ending in {issue_hash[-5:]} - created {issue_ticket.key} for this issue"

        # If we have a parent assignee, assign them to the sub-task ticket and transition it to reported
        if assignee is not None:
            output += " - the repository ticket has an assignee, assigning the ticket to them also"
            issue_ticket.update(
                assignee = {
                    "id": assignee
                }
            )
            self.j.transition_issue(issue_ticket, self.REPORTED_TRANSITION)

        print(output)

    def check(self):
        # self.s.update("checking for existing JIRA tickets")
        print(f"[jira][check] checking if we need to make new JIRA tickets for any issues")

        issue_tickets = []

        for issue in self.i:

            # Create a jira key to store the matching ticket if present
            issue["jira"] = ""

            issue_hash = issue["uid"]
            create = True

            # Only do this code if there are subtasks to look through - otherwise we're going to make the first one anyway
            if self.subtasks_exist:
                # print(f"[jira][check] {issue_hash[-5:]} - searching subtasks for matching id")

                for subtask in self.subtask_information:
                    key = subtask["key"]
                    status = subtask["status"]
                    s_hash = subtask["hash"]

                    if s_hash is not None and s_hash == issue_hash:
                        # print(f"[jira][check] {issue_hash[-5:]} - > found ticket with matching hash: {key} - {summary}")

                        if status in self.open_statuses:
                            # print(f'[jira][check] {issue_hash[-5:]} - >>> this ticket has a status of "{status}", we won\'t raise a new one')
                            issue["jira"] = key

                            # if the description has changed, update it
                            ticket = self.j.issue(key)
                            if issue["description"] != ticket.fields.description.split("\n\nh4.")[0]:
                                ticket.update(
                                    description = self.__prepare_description(issue)
                                )

                            # if status == "vulnerability accepted":
                            #     print("[jira][create_jira_tickets] >>> we will not comment on this issue either as it is accepted")
                            # issue_tickets.append(subtask.key)
                            create = False
                            break
                        # else:
                            # print(f"[jira][check] {issue_hash[-5:]} - >>> {key} is closed")
        
            if create:
               issue_tickets.append(issue)

        # Where required we'll asynchronously create the JIRA tickets to be efficient
        if len(issue_tickets) > 0:
            with ThreadPoolExecutor(max_workers = self.MAX_WORKERS) as executor:
                executor.map(self.__create_jira_ticket, issue_tickets)
            print(f"[jira][check] {len(issue_tickets)} tickets created!")
            self.s.update(f"{len(issue_tickets)} tickets created")
        else:
            print("[jira][check] no new tickets created!")
            self.s.update("no new tickets created")

    
    def __prune_ticket(self, subtask_info):
        # Check if this is a zombie ticket and it is already a fixed issue
        if subtask_info["zombie"]:
            issue = self.j.issue(subtask_info["key"])
            self.j.transition_issue(issue, self.FIXED_TRANSITION)
            self.j.add_comment(issue, self.FIXED_COMMENT)
            print(f'[jira][__prune_ticket] transitioned zombie \"{issue}\" to a fixed state as it was not in this report')


    def prune(self):
        """
        Transition issues that aren't from this report, but were before.
        """

        print()
        print(f"[jira][prune] looking for isolated tickets and marking them as fixed")

        # subtasks_exist must be True if there are zombie subtasks
        # which is why we don't check self.subtasks_exist
        if self.zombie_count > 0:
            with ThreadPoolExecutor(max_workers = self.MAX_WORKERS) as executor:
                executor.map(self.__prune_ticket, self.subtask_information)
            self.s.update(f"pruned {self.zombie_count} tickets")
        else:
            print(f"[jira][prune] there are no zombie tickets to prune")
            self.s.update("no tickets to prune")
        